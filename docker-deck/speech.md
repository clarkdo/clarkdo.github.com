# 介绍
大家好, 首先谢谢各位对这次的技术沙龙的支持, 我是本轮的分享人杜欣, 目前就职于众蓝影云研发部, 主要负责技术研发与设计工作。

今天我分享的主题是[微架构与容器化的持续交付], 主要会为大家分享一下, 微服务的一些概念和实践, 以及我们是为什么使用docker以及是如何于docker进行结合来实现持续集成的。

# 微服务

首先, 进入我们今天的正题, 微服务, 大家可能或多或者都了解和听说过微服务, 其实微服务背后的理念就是是将大型、复杂且历时长久的应用在架构上设计为内聚的服务, 从而使得这些服务能够随着时间的流逝而演化。

我想大家可能大多都是有Java背景的开发或者架构师, 接下来我会从 Java 生态系统出发, 为大家介绍一下什么是微服务。

## What 微服务

在 Java 生态系统中构建微服务的策略主要有：container-less, self-contained 和 in-container 这三种策略, 可能大家初一看这三个名词, 并不能很清晰的理解其中包含的意思。

所以, 接下来我就来具体的解释一下这三种策略的含义。

1. 首先, Container-less 类型的微服务把应用程序及其所有依赖打包成单一的 jar 文件。 它会启用所谓的单 jar 部署（也可称作“fat jar部署”），这也就意味着，应用程序及其所有依赖都会被打包成单一的jar文件，并且作为独立的Java进程运行。

  该方法的第一个优点就是当对应用的规模进行伸缩时，服务很容易按需求快速启动和停止；另一优点是方便部署，你只需要传递一个 jar 文件即可。

  该方法的缺点就是库的兼容性。对于事务支持这类问题，你需要自己来实现，或必须引入第三方库才能实现。而后，如果你需要更多支持，例如持续性问题的支持，你就需要解决第三方库之间的兼容性问题。

2. 另一种单 jar 部署就是使用一个嵌入式框架来构建服务。在此方法中，框架提供了所需服务的实现方法，开发者可以选择在项目中包括哪些服务。

  这种策略与 container-less 有很多相似之处，但两者的区别在于，self-contained 方法会提供一套相互兼容的第三方库。所以，该方法不存在库兼容性问题。
  比如现在非常流行的 Spring Boot 和 Spring Cloud Netflix, 它允许你选择各种 Spring 工具和其它流行的工具，然后把它们和你的应用打包成一个 jar 文件。

  self-contained 方法的优点是你可以自主选择用于服务运行的项目。
  这种方法的缺点是配置更加复杂，由于它在实际的服务中构建所需的容器功能，由此产生的 jar 文件也会稍大一些。

3. In-container 微服务会打包一个完整的 Java EE 容器，并且它的服务是在 Docker image 中实现。 它将 Java EE 容器作为所需平台, 由于容器会提供Java EE API，这也就意味着所产生的 war 文件是非常精简的。

  该方法的优点是，容器通过标准 API 提供了经过测试和验证的标准功能的实现。因此，开发者可以完全聚焦于业务功能，并在应用代码之外维护底层代码。

  另一个优点是，应用程序代码不依赖 Java EE 应用服务器，无论该应用部署到 GlassFish、WildFly、WebLogic、WebSphere 还是任何与 Java EE 兼容的其他实现系统。
该方法的缺点是你需要把服务部署到容器中，这样就增加了部署的复杂性。

## Why 微服务

介绍了这么多, 可能大家对于微服务有了一个大体的认识, 那么我们究竟为什么要去选择使用微服务呢?

1. 首先, 在传统行业内, 想必在座的各位都有过体会, 一个项目其实就是多个子系统的堆砌, 可能初期应用是比较简洁的, 但随着时间变得巨大。

  在每个迭代里，开发团队都会新加许多行代码。几年后，原本小而简单的应用会变得臃肿。一旦应用变得庞大、复杂，开发团队就会饱受折磨，苦苦挣扎于开发和交付中, 甚至任何一个开发者都无法完全理解。最后，甚至连修复 bug 和实施新功能也变的极其困难且耗时颇多。更可怕的是，这是一个向下的螺旋发展。代码库越难理解，正确的修改就越难。最后你会深陷庞大的、无法估量的泥潭之中。

  而且应用的扩展以及技术演进也很难, 采用新框架和语言极其困难。举例来说，你有百万行使用 Mybatis 的代码，如果要使用 Hibernate 重写代码，无论时间还是成本都将非常高昂，即便新框架更适合项目, 也很难成功迁移, 这也就成为使用新技术的阻碍。

  并且应用的尺寸也会拖慢开发进度, 无法响应快速的变化。应用越大，启动时间越长。譬如一个应用, 可能启动时间长达 10几甚至几十分钟, 如果开发者在开发中不得不频繁重启应用服务器，那大量时间就被浪费，生产效率也饱受其害。

  庞大且复杂的应用的另一大问题就是难以进行持续部署。现在， 持续集成以及容器化应用的发展水平足以在单日内多次将修改推送到测试甚至生产环境。然而要让复杂的单个应用达到此水平却极为棘手。想更新应用的单个部分，必须重新部署整个应用，漫长的启动时间更是雪上加霜。

  另外，由于不能完全预见修改的影响，你不得不提前进行大量人工测试。结果就是，持续部署变得不可能, 极大的增加了运维与集成的成本。

2. SOA能够比较简单的创建应用；使服务消费者免于服务实现的改变所带来的影响；SOA能够升级单个服务或服务消费者而无需重写整个应用，也无需保留已经不再适用于新需求的现有系统。

  总而言之，SOA以借助现有的应用来组合产生新服务的敏捷方式，提供给企业更好的灵活性来构建应用程序和业务流程, 从而提升了工作效率和自适应性。

  SOA早期均使用了总线模式，这种总线模式是与某种技术栈强绑定的，比如：J2EE。这导致很多企业的遗留系统很难对接，切换时间太长，成本太高，新系统稳定性的收敛也需要一些时间。最终SOA看起来很美，但却成为了企业级奢侈品，中小公司都望而生畏。

3. 其实你微服务与SOA并没有很大的分界线, 可以把它想成是 SOA 的一种实践方式，正如 XP 或 Scrum 是敏捷软件开发的实践方式一样。 不同于构建单一、庞大的应用，微服务架构将应用拆分为一套小且互相关联的服务, 服务的本质就是行为（业务活动）的抽象。

  一个微服务一般完成某个特定的功能，比如订单管理、客户管理等。每个微服务都是一个微型应用，有着自己六边形架构，包括业务逻辑和各种接口。有的微服务通过暴露 API 被别的微服务或者应用客户端所用；有的微服务则通过网页 UI 实现。在运行时，每个实例通常是一个云虚拟机或者 Docker 容器。

  微服务架构模式有很多好处。首先，庞大的应用得到了有效的分解, 为多个服务方法解决了复杂性问题。在功能不变的情况下，应用被分解为多个可管理的分支或服务。每个服务都有一个用 RPC- 或者消息驱动 API 定义清楚的边界。微服务架构模式给采用单体式编码方式很难实现的功能提供了模块化的解决方案，由此，单个服务很容易开发、理解和维护。

  第二，这种架构使得每个服务都可以有专门开发团队来开发。开发者可以自由选择开发技术，提供 API 服务。当然，许多公司试图避免混乱，只提供某些技术选择。然后，这种自由意味着开发者不需要被迫使用某项目开始时采用的过时技术，他们可以选择现在的技术。甚至于，因为服务都是相对简单，即使用现在技术重写以前代码也不是很困难的事情。

  第三，微服务架构模式使得每个微服务独立部署，开发者不再需要协调其它服务部署对本服务的影响。这种改变可以加快部署速度，譬如 UI 团队可以采用 AB 测试并快速部署变化。微服务架构模式使得持续化部署成为可能。
  最后，微服务架构模式使得每个服务独立扩展。你可以根据每个服务的规模来部署满足需求的实利。甚至于，你可以使用更适合于服务资源需求的硬件。

  但是, 微服务也并不是万能的银弹, 它也存在着一些不足, 比如: 微服务应用是分布式系统，由此会带来固有的复杂性, 发者需要在RPC或者消息传递之间选择并完成进程间通讯机制。更甚于，他们必须写代码来处理消息传递中速度过慢或者不可用等局部失效问题; 再者就是分区的数据库架构, 使一些业务不得不使用一个最终一致性的方法，从而对开发者提出了更高的要求和挑战。

### 架构比较

这张图就为三种架构模式提供了一个很形象的比较, 传统的单体应用是非常臃肿且耦合的, 而中间的SOA则变得更加的有章可循, 通过ESB来协调各个服务之间的交互, 但是比较死板, 最后的微服务, 则消除了服务间的耦合, 达到了更好的灵活性和自治性。

## Where 微服务

介绍了关于三种架构的比较, 那么如何判断微服务是否适合我们的项目呢?

### 架构场景

脱离业务场景，空谈架构绝对是不合理的。看起来再完美的架构，如果无法在业务场景中落地实施，也只是空谈。因此架构需要服务于业务，针对不同的业务场景架构设计也会不同，架构设计不必追求高大全，简单而优美的架构，如果能满足业务发展需求，便是好架构。

此外，好的架构不完全是设计出来的，是随着业务量、请求量的增长演化而来的。微服务架构之所以得到广泛认可，源于业务的多变性和不可预测性，微服务架构能够不断的自演化，进而快速适应业务变化。但相对于单体架构且经过严格定义的大规模开发项目，微服务架构要求大家面对由众多小型服务所构成的复杂生态系统。鉴于此，如果业务规划或者团队不具备以下的条件，则不建议各位盲目迈向微服务这一新兴架构领域，或者从试点入手，逐步在团队中推行微服务架构。

- 对速度要求高, 需求变化非常频繁
- 变更发生在应用的不同区域, 功能隔离与快捷部署的需求远高于模块间聚合性的要求
- 功能可以简单的分割为多个独立的组件

### 架构场景样例

这张图呢, 就是微服务的一个典型的架构样例, 各个服务间通过一个API的网关对外提供接口, 外部可以是各种PC或者移动设备, 内部各个服务间是独立的, 它们唯一的关系可能就是通过暴露接口进行交互, 服务之间耦合性是很低的, 但是对我提供的服务却又是很内聚的。

## Our Attempt

### 尝试
基于以上关于微服务的优势, 我们在过去的一段时间里也做了很多的尝试, 比如:
- 业务横向拆分
- 构建自治型, 专注型的服务应用
- 服务间灵活稳定的相互方式
- 保证持续部署及运行能力
- 实践可行的服务注册、发现、负载均衡方案
- 完善日志监控, 性能度量

### 众蓝架构
这张图呢, 就是我们其中一个项目所采用的一个整体的架构图。 API网关是使用Nginx+Lua的这么一套设计。 内部的各个服务大都是基于springboot技术栈的这么一套结构, 根据业务和数据模型, 各服务采用不同的存储方案, 比如redis, mysql, ehcache, oracle等。

关于服务治理这部分, 之前采用的是淘宝开源的dubbo框架, 现在已经向netflix oss迁移, 因为Netflix是一家成功实践微服务架构的互联网公司，几年前，Netflix就把它的几乎整个微服务框架栈开源贡献给了社区，它包含了要很完整的, 服务注册,发现,负载均衡和健康检查的策略, 并且在大规模分布式微服务环境中经过多年的生产实战验证，正逐步被社区接受为构造微服务框架的标准组件。

Spring Cloud也主要是基于对Netflix开源组件的进一步封装，方便Spring开发人员构建微服务基础框架。 监控方面, 分为业务监控, 应用健康以及服务器健康, 分别通过ELK, Metrics与Zabbix实现。

# Docker
## 挑战
在微服务的研究过程中, 我们也遇到了一些问题和挑战, 这也是我们走上容器化道路的一个缘由。
### 面临问题
三个比较重要的问题是: 如何能高效的处理RPC的调用, 如何在敏捷开发及快速迭代下, 迅速的持续构建, 部署并管理多个服务, 最后就是, 由于从单体应用转变到微服务, 势必会大大增加了服务间的网络通信, 网络的通信管道如何管理也是一个问题。
### 问题思考
这时候, 我们看到了容器化技术, 也进一步引发了团队思考, 容器化技术现在发展这么迅猛, 但他能否为我们解决我们目前的问题呢, 比如刚刚三个问题在的后两个, 基于此类问题, 我们希望docker可以为我们实现:
- 配置化, 快速, 可重复式的构建服务
- 托管式的发布及管理服务
- 成熟的网络方案及集群管理策略

## Why docker

### 容器化必然性

经过一段时间的研究, 我们发现这些问题docker都比较完美的给出了成熟的解决方案.
- 通过容器化技术, 我们可以几乎0基础的快速并且可重复的构建出应用, 它与目前主流的CI及代码托管工具都可以很方便的集成。
- 并且docker自身提供了一套非常成熟并且也在持续演进的托管式的镜像发布和管理的服务, 我们可以灵活的使用dockerhub或者私有镜像中心进行灵活管理。
- 使用docker之后, 无论在部署还是交付阶段, 都无需担心环境的不一致问题, 极大的节省了测试和运维成本。
- 网络方案层面, 包括kubernates, Flannel在内的很多系统, 都提供了灵活的集群及网络方案。
- 并且docker的生态发展的如此迅猛, 通过包括**时速云**为代表一些CaaS平台, 可以实现灵活敏捷的交付, 例如方便的进行自动部署, 弹性伸缩, 存储挂载, 动态扩容, 通过这样完善的平台, 可以使我们的服务保障在一个可控的状态下, 增强了对业务, 性能的可操作性。

### 容器化优势
在我们实际使用了docker一段时间后, 我们发现了一些容器化后带来的优势。

开发层面上, 由于容器化技术的隔离性, 开发人员无需关心对平台和语言的依赖性, 加强了技术灵活度, 对于微服务的异构型, 基于业务的选型能力给予了强有力的支持。

交付阶段, 开发人员可以自己设计从开发到测试到最终发布的整个流程, 和运维可以更加紧密合作, 将整个流程整合在一起, 也为DevOps打下了基础, 再通过引入自动化测试等技术, 使得整个整个软件产品的生命周期实现了可持续的运转, 这整个流程就是一个服务为导向的可持续的生产，测试，发布的生态环境。

## CI/CD

接下来, 我来为大家介绍一下我们在持续集成以及交付上做的一些努力和尝试。

这张图就是我们目前大体的一个持续集成的流程图,
- 首先开发人员在本地开发, 开发完成后通过Gitlab向主干分支提交代码合并的请求。
- 于此同时, Gitlab的回调方法会触发Jenkins的构建任务, Jenkins会基于本次提交的变化进行代码质量检测, 单元测试。
- 最终构建出增量的容器, 进行部署与集成, 容器启动后, 测试人员进行测试, 测试通过后, 进行代码的合并以及镜像的推送

这张图就是我们众蓝影云的一个比较详细的持续集成以及交付的流程,
