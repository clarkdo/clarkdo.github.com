---
layout: post
title: Java设计模式:JDK中的应用
category: Design Patterns Stories
comments: true
---

**注:本文为译文,原文出处[java-design-patterns-in-stories](http://www.programcreek.com/java-design-patterns-in-stories/)**


###**创建型模式**

####**抽象工厂模式**(通过创建的方法返回工厂本身, 可以依次创建另一个抽象/接口类型)

- javax.xml.parsers.DocumentBuilderFactory#newInstance()
- javax.xml.transform.TransformerFactory#newInstance()
- javax.xml.xpath.XPathFactory#newInstance()



####**生成器模式**(通过创建的方法返回实例本身)

- java.lang.StringBuilder#append() (非同步的)
- java.lang.StringBuffer#append() (支持同步)
- java.nio.ByteBuffer#put() (与之相同的有: `CharBuffer`, `ShortBuffer`, `IntBuffer`, `LongBuffer`, `FloatBuffer` 和 `DoubleBuffer`)
- javax.swing.GroupLayout.Group#addComponent()
- java.lang.Appendabled 的所有实现

####**工厂模式**(通过创建的方法返回一个抽象/接口类型的实现)

- java.util.Calendar#getInstance()
- java.util.ResourceBundle#getBundle()
- java.text.NumberFormat#getInstance()
- java.nio.charset.Charset#forName()
- java.net.URLStreamHandlerFactory#createURLStreamHandler(String) (按协议返回单例对象)

####**原型模式**(通过创建的方法返回一个包含相同属性的不同实例)

- java.lang.Object#clone() (类必须实现 java.lang.Cloneable)

####**单例模式**(通过创建的方法在任何时间都返回一个相同实例(通常是它本身))

- java.lang.Runtime#getRuntime()
- java.awt.Desktop#getDesktop()

###**结构型模式**

####**适配器模式**(接收不同抽象或接口类型的一个实例, 并返回一个装饰或重写了该实例的本身/其他的抽象/接口类型的实现)

- java.util.Arrays#asList()
- java.io.InputStreamReader(InputStream) (returns a Reader)
- java.io.OutputStreamWriter(OutputStream) (returns a Writer)
- javax.xml.bind.annotation.adapters.XmlAdapter#marshal() and #unmarshal()

####**桥接模式**(接收不同抽象或接口类型的一个实例, 并返回一个委托或使用了该实例的本身/其他的抽象/接口类型的实现)

- 一时之间没有想到. 一个虚构的例子: `new LinkedHashMap(LinkedHashSet<K>, List<V>)`返回一个不可变的链式map, 并且不会克隆内部元素而是直接使用他们. `java.util.Collections#newSetFromMap()` 和 `singletonXXX()`方法是有些接近这个模式的.

####**组合模式**(通过行为式的方法接收一个相同的抽象或接口类型的实例转换为一个树状结构)

- java.awt.Container#add(Component) (几乎所有Swing都是这样)
- javax.faces.component.UIComponent#getChildren() (几乎所有JSF UI都是这样)

####**装饰器模式**(通过创建的方法接收一个相同的抽象或接口类型的实例, 并添加附加的行为)

- java.io.InputStream, OutputStream, Reader 和 Writer的子类拥有一个持有相同类型的实例构造器.
- java.util.Collections, the checkedXXX(), synchronizedXXX() 和 unmodifiableXXX().
- javax.servlet.http.HttpServletRequestWrapper 和 HttpServletResponseWrapper

####**门面模式**(通过行为式的方法实现, 该方法内部使用不同的独立的抽象或接口类型的实例)

- javax.faces.context.FacesContext, 它内部之间使用 `LifeCycle`, `ViewHandler`, `NavigationHandler` 和很多无需最终能够用户关心的抽象/接口类型(可通过注入覆写).
- javax.faces.context.ExternalContext, 它内部使用`ServletContext`, `HttpSession`, `HttpServletRequest`, `HttpServletResponse`等.

####**享元模式**(通过创建的方法返回一个缓存的实例, 有一些"多例"的思想)

- java.lang.Integer#valueOf(int) (类似的还包括: `Boolean`, `Byte`, `Character`, `Short` 和 `Long`)

####**代理模式**(通过创建的方法返回指定的抽象或接口类型的实现, 该实现依次委托或使用了指定抽象或接口类型的不同实现)

- java.lang.reflect.Proxy
- java.rmi.*, 事实上包括所有的API.